Q1.1 : 
    - J'ai déclaré une méthode privée qui effectue le "clamping" à la position. La méthode est privée car le clamping est un détail d'implémentation inutile au développeur utilisateur de la classe CircularCollider. En fait j'ai utilisé deux méthodes privées afin de ne pas dupliquer le code pour la coordonnée x et y sur lesquelles le même algorithme est effectué.

Q1.2 : 
    - L'avantage d'expliciter est que si un autre développeur reprend notre code, il est sûr que le constructeur de copie et l'operateur = font ce qui a été prévu par le concepteur de la classe. 

Q1.3 : 
    - Afin de tester les 9 possibilité, j'ai testé toutes les combinaisons de "to + i * {0, height} + j * {weight, 0}" i, j étant prenant les valeurs -1, 0, 1. Donc en faisant deux boucles for imbriquée, il est facilement possible de réalier toutes ces combinaisons.

Q1.4 :
    - J'ai passé tous les arguments de types Vec2d et CircularCollider en références constantes pour les méthodes : directionTo, distanceTo, move et operator+=

Q1.5 :
    - Les méthodes getPosition, getRadius, directionTo, distance sont toutes des prédicats donc doivent être déclarées comme const.

Q1.6 :
    - Les 3 opérateurs demander sont simplement des appels aux fonctions isCircularColliderInside, isPointInside et isColliding de l'objet sur lequel l'opérateur est appliqué.

Q1.7 :
    - operator=  : interne pour éviter une copie inutile
    - operator+= : interne pour éviter une copie inutile
    - operator>  : (body1 > body2) externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator|  : externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator>  : (body > point) externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator<< : externe par obligation 

Q1.8 : 
    - J'ai passé tous les arguments de types Vec2d, CircularCollider et std::ostream en références constantes pour les méthodes : isCircularColliderInside, isColliding, isPointInside, operator> (les deux surcharges), operator|, operator<<

Q1.9 :
    - les méthodes isCircularColliderInside, isColliding, isPointInside sont toutes des prédicats donc doivent être déclarées comme const.

Q2.1 :
    - J'ai déclaré draw et update en tant que prédicats. Update va sûrement modifier les animaux (leur position par exemple) mais pas l'environnement en tant que tel. Les 3 autres méthodes modifient directement les 2 attributs.

Q2.2 :
    - Pour interdire l'accès au constructeur de copie il faut utiliser l'instruction delete dans le fichier de header de la manière suivante : Environment(Environment const& other) = delete;

Q2.3 :
    - Les animaux étant référencé par des pointeurs dans un environnement, il faut donc les désallouer avant de détruire l'objet. Je désalloue les Animaux dans la méthode clean avant de vider la liste. Je fais simplement appel à cette méthode depuis le destructeur.

Q2.4 :
    - Le comportement des touches R et T est défini dans le fichier Application.cpp dans la méthode Application::handleEvent(sf::Event event, sf::RenderWindow& window). Cette méthode est appelé par la méthode run lorsque qu'un événement est détecté dans la boucle.

Q2.5 :
    -  Vec2d computeForce() const est la méthode qui calcule la force telle qu'elle est décrite dans l'énoncé. Elle n'a pas besoin d'argument car toutes les valeurs sont disponible dans les attributs et retourne le vecteur représentant la force.
    -  void update(Vec2d force, sf::Time dt) est la méthode qui met à jour les attributs, elle prend en paramêtre le vecteur force calculée avec la méthode précédente et le delta t.

Cette combinaison permet une potentielle redéfinition de la méthode de calcul de la force dans une spécialisation de ChasingAutomaton. 

Q2.6 :
    - J'ai mis un type énuméré dans l'interface publique de la classe ChasingAutomaton. Je l'ai mis dans la classe car ce type n'a de sens que dans le cadre d'un chasingAutomaton. Mais il nous faut l'accès à l'extérieur donc je l'ai mis en public. Ensuite, j'ai rajouté un attribut privé qui stocke la décélération dans un double et une méthode publique : setDeceleration(Deceleration deceleration) qui affecte la bonne valeur de décélération à l'attribut privé selon le type énuméré passé en paramêtre. Par défaut, la décélération est initialisée à la décélération moyenne (0.6)

Q2.7 :
    - setRotation modifie la direction de l'animal, si on suppose que l'animal est autonome, il ne faudrait pas que l'extérieur puisse changer la direction. Par contre les spécialisations (les animaux en tant que tel) doivent être capable de se diriger, donc le lien protected offre cette fonctionnalité.

Q2.8 :
    - il faut rajouter l'affichage de l'animal dans la méthode d'affichage de l'environnement (méthode draw).

Q2.9 :
    - Comme justifié à la réponse 2.7, la méthode setRotation de Animal a un accès protected. Donc pour que l'animal change de direction, il faut que ce soit l'animal lui même qui décide de changer de direction. Comme les méthodes protected sont accessibles depuis les sous-classes, la classe DummyAnimal peut changer sa direction par un appel à setRotation. Dans ce cas la classe DummyAnimal casse l'encapsulation en offrant le changement de rotation via une méthode publique (void setHeading(Vec2d const& heading)) qui fait appel à la méthode protected setRotation. Ceci permet à un utilisateur de DummyAnimal de changer la direction.

Q2.10 :
    - getTargetsInSightForAnimal doit retourner un ensemble donc il faut retourner une liste de cible. Nos cibles étant dans Vec2d. Le type de retour logique est std::list<Vec2d>.

Q2.11 :
    - il faut compléter la méthode update de la class Environment. Dans cette méthode, j'itère sur tous les animaux et appelle leur méthode update.

Q3.1 :
    - getStandardMaxSpeed, getMass, getRandomWalkRadius, getRandomWalkDistance, getRandomWalkJitter, getViewRange et getViewDistance sont désormais des méthodes virtuelles pures de la classe Animal. C'est un cas typique ou les méthode doivent être abstraite à ce niveau et spécialisées dans les sous-classes.

    - Le mot clé override est pertinent dans les classes Gerbil et Scorpion dans le prototype des 7 méthodes virtuelles que l'on substitue de la super classe Animal. 

Q3.2 :
    - Il faut modifier la valeur associé à l'énergie initiale d'une gerbille.
      Pour y accéder, il faut suivre la hierarchie suivante :
{
    ...   
    "simulation":{
        ...
        "gerbil":{
            ...
            "energy":{
               "initial":VALEUR_A_MODIFIER,

Retouches à l'environnement :
La methode getEntitiesInSightForAnimal casse l'encapsulation, car donne des pointeurs sur les entités organiques de l'environnement. Donc un utilisateur de la classe peut modifier ou supprimer des entités organiques.

Q3.3 :
    - Pour l'instant tous les enfants de OrganicEntity ont une méthode update et draw, donc je fais hériter OrganicEntity de Updatable et drawable en plus de CircularCollider. 

Q3.4 :
    - Tester le type des objets à l'exécution est une très mauvaise pratique. Car cela nous empêche de bénéficier de la force du polymorphisme et rend nos programmes beaucoup plus compliqué à maintenir. Si on rajoute un type dans une hierarchie, il faudra aller rajouter les cas partout ou on a fait des tests. Alors que si la conception est bonne il suffira de coder la nouvelle classe et tout le reste du code manipulera cette nouvelle classe sans devoir y changer une ligne. On perd donc en flexibilité et maintenabilité.

Q3.5 :
    - Selon moi, les affichages de debug que l'on a pour le moment sont très spécifiques aux animaux, donc toutes les méthodes d'affichage de debugging sont placées dans la classe Animal. Ce qui donc ne change rien à l'héritage de Drawable discuté à la question 3.3.

Q3.6 :
    - J'ai utilisé le méchanisme des méthodes virtuelles. J'ai mis une méthode virtuelle getLongevity() dans la classe OrganicEntity. Cette méthode retourne la valeur par défaut. Ensuite, j'ai re-défini (override) getLongevity() dans les classes Scorpions et Gerbilles afin de retournées leur longévité.

Q3.7 :
    - Je teste si l'animal doit être enlevé dans la boucle de la méthode update de l'environnement. Je fais bien entendu ce test après avoir mis à jour l'animal. Il faut faire attention de bien delete l'entité pour éviter les fuites de mémoires. 

Q3.8:
    - J'ai tout d'abord ajouté trois parametres dans les fichiers JSON pour le seuil de fatigue (parametre des animaux) et pour la vitesse en étant fatigué (pour la gerbille et le scorpion). Ensuite, dans la méthode getMaxSpeed je teste si le niveau d'énergie est au dessous du seuil et dans ce cas j'utilise la vitesse fatigué au lieu de la standard maximale.

Q3.9:
    - On aurait pu mettre toutes les méthodes gérant les collisions directement dans OrganicEntity. L'avantage que je vois est que l'on réduit la profondeur de notre hierarchie de classe, mais par contre cela rend la conception moins souple. Avec circular collider on pourrait ajouter des entités non organiques étant des circular collider par exemple. Il y a aussi un avantage pour l'organisation des méthodes, toutes les méthodes servant juste aux collisions sont dans un fichier séparé. Cela nous donne donc une séparation logique des méthodes par thème.

Q3.10:
    - La méthode meet test la condition suivante this->matable(entity) && entity->matable(this). Ce qui utilise le double dispatch sans faire de tests de type.

Q3.11:
    - La gestation est implémentée sous la forme d'un compteur qui est initialisé au temps de gestation de l'animal et qui est décrémenté à chaque update. Lorsque le temps est écoulé, l'animal s'arrête et donne naissance à ses enfants.

Q3.12:
    - Dans la classe Animal, la méthode virtuelle pure suivante  est déclarée :  virtual Animal* giveBirth() = 0;
      Cette méthode est implémentée dans Scorpion et Gerbille et renvoit un nouvel animal du même type.

Q3.13:
    - Le nombre d'enfant est stocké dans un attribut (childrenPending_). Cet attribut vaut zéro pour les mâles et lorsque que les femelles ne sont pas en gestation. 

Q3.14:
    - Il ne serait pas nécessaire d'avoir un attribut. Mais dans l'idée de modularisation et de séparation des taches par méthodes, je trouve essentiel d'avoir une liste d'ennemies. Car je découvre les ennemies dans la méthode AnalyseEnvironment() puis je décide le state dans update state et ensuite seulement je calcule la force dans depuis la méthode update. Donc pour calculer la force il me faut les prédateurs. Donc j'ai implémenté en gardant une liste de prédateur en attributs.

Q4.1:
    - La classe Wave hérite de CircularCollider comme demandé dans l'énoncé, mais aussi de Updatable et Drawable car c'est un objet qui évolue au cours du temps et qui sera dessiné.

Q4.2:
    - Le temps écoulé depuis le début de la propagation est comptabilisé avec un timer en attribut (sf::Time timer_). Ce timer est incrémenté par la méthode update.

Q4.3:
    - Afin de gérer les waves dans l'environnement, il faut y ajouter une liste de waves qui sera populé par addWave, et ensuite ajouter les traitements sur cette liste dans les méthodes update, draw et clean.

Q4.4:
    - Il faut ajouter une boucle de dessin des obstacles dans la méthode draw et gérer la fin de vie des objets dans la méthode clean. J'ai auss ajouté std::list<Obstacle *> getObstacleColliding(Wave* wave) qui retourne les obstacles qui sont en collisions avec une onde afin de détecter les collisions avec les arcs.
