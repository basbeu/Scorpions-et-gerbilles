Q1.1 : 
    - J'ai déclaré une méthode privée qui effectue le "clamping" à la position. La méthode est privée car le clamping est un détail d'implémentation inutile au développeur utilisateur de la classe CircularCollider. En fait j'ai utilisé deux méthodes privées afin de ne pas dupliquer le code pour la coordonnée x et y sur lesquelles le même algorithme est effectué.

Q1.2 : 
    - L'avantage d'expliciter est que si un autre développeur reprend notre code, il est sûr que le constructeur de copie et l'operateur = font ce qui a été prévu par le concepteur de la classe. 

Q1.3 : 
    - Afin de tester les 9 possibilité, j'ai testé toutes les combinaisons de "to + i * {0, height} + j * {weight, 0}" i, j étant prenant les valeurs -1, 0, 1. Donc en faisant deux boucles for imbriquée, il est facilement possible de réalier toutes ces combinaisons.

Q1.4 :
    - J'ai passé tous les arguments de types Vec2d et CircularCollider en références constantes pour les méthodes : directionTo, distanceTo, move et operator+=

Q1.5 :
    - Les méthodes getPosition, getRadius, directionTo, distance sont toutes des prédicats donc doivent être déclarées comme const.

Q1.6 :
    - Les 3 opérateurs demander sont simplement des appels aux fonctions isCircularColliderInside, isPointInside et isColliding de l'objet sur lequel l'opérateur est appliqué.

Q1.7 :
    - operator=  : interne pour éviter une copie inutile
    - operator+= : interne pour éviter une copie inutile
    - operator>  : (body1 > body2) externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator|  : externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator>  : (body > point) externe car peut l'être sans rajouter de copie ni utiliser friend
    - operator<< : externe par obligation 

Q1.8 : 
    - J'ai passé tous les arguments de types Vec2d, CircularCollider et std::ostream en références constantes pour les méthodes : isCircularColliderInside, isColliding, isPointInside, operator> (les deux surcharges), operator|, operator<<

Q1.9 :
    - les méthodes isCircularColliderInside, isColliding, isPointInside sont toutes des prédicats donc doivent être déclarées comme const.

Q2.1 :
    - J'ai déclaré draw et const en tant que prédicats. Update va sûrement modifier les animaux (leur position par exemple) mais pas l'environnement en tant que tel. Les 3 autres méthodes modifient directement les 2 attributs.

Q2.2 :
    - Pour interdire l'accès au constructeur de copie il faut utiliser l'instruction delete dans le fichier de header de la manière suivante : Environment(Environment const& other) = delete;

Q2.3 :
    - Les animaux étant référencé par des pointeurs dans un environnement, il faut donc les désallouer avant de détruire l'objet. Je désalloue les Animaux dans la méthode clean avant de vider la liste. Je fais simplement appel à cette méthode depuis le destructeur.

Q2.4 :
    - Le comportement des touches R et T est défini dans le fichier Application.cpp dans la méthode Application::handleEvent(sf::Event event, sf::RenderWindow& window). Cette méthode est appelé par la méthode run lorsque qu'un événement est détecté dans la boucle.

Q2.5 :
    -  Vec2d computeForce() const est la méthode qui calcule la force telle qu'elle est décrite dans l'énoncé. Elle n'a pas besoin d'argument car toutes les valeurs sont disponible dans les attributs et retourne le vecteur représentant la force.
    -  void update(Vec2d force, sf::Time dt) est la méthode qui met à jour les attributs, elle prend en paramêtre le vecteur force calculée avec la méthode précédente et le delta t.

Cette combinaison permet une potentielle redéfinition de la méthode de calcul de la force dans une spécialisation de ChasingAutomaton. 

Q2.6 :
    - J'ai mis un type énuméré dans l'interface publique de la classe ChasingAutomaton. Je l'ai mis dans la classe car ce type n'a de sens que dans le cadre d'un chasingAutomaton. Mais il nous faut l'accès à l'extérieur donc je l'ai mis en public. Ensuite, j'ai rajouté un attribut privé qui stocke la décélération dans un double et une méthode publique : setDeceleration(Deceleration deceleration) qui affecte la bonne valeur de décélération à l'attribut privé selon le type énuméré passé en paramêtre. Par défaut, la décélération est initialisée à la décélération moyenne (0.6)
